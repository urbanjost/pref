." Text automatically generated by txt2man
.TH "untitled" "" "March 26, 2022" "" "" " "
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." set smaller margin and spacing options
.ta T 0.2i
.nr IN 0.2i
." -----------------------------------------------------------------
.RS
Project is up to date
.SH NAME
\fBprep\fP(1) - [DEVELOPER] pre-process FORTRAN source files
(LICENSE:MIT)

.SH SYNOPSIS
.TP
.B \fBprep\fP
[[-D] \fIdefine_list\fP]
[-I \fIinclude_directories\fP]
[-i \fBinput_file\fP(s)]
[-o \fIoutput_file\fP]
[-\fB-system\fP]
[-\fB-verbose\fP]
[-\fB-prefix\fP character|ADE]
[-\fB-keeptabs\fP]
[-\fB-noenv\fP]
[-\fB-width\fP \fIn\fP]
[-d ignore|remove|blank]
[-\fB-comment\fP default|doxygen|ford|none]
[-\fB-type\fP \fIFILE_TYPE\fP | \fB--start\fP \fISTART_STRING\fP \fB--stop\fP \fISTOP_STRING\fP]
[-\fB-ident\fP]
[-\fB-version\fP]
[-\fB-help\fP]
.fam T
.fi
.SH DESCRIPTION

The pre-processor \fBprep\fP(1) will interpret lines with "$" (by default) in
column one, and will output no such lines. Other input is conditionally
written to the output file based on the case-insensitive directive names
encountered in the input.
.PP
\fBprep\fP(1) does not support parameterized macros but does support string
substitution and the inclusion of free-format text blocks that may be
converted to Fortran comments or CHARACTER variable definitions (while
optionally simultaneously being used to generate documentation files).
Combined, these features allow for basic templating.
.PP
An exclamation character FOLLOWED BY A SPACE on a valid directive begins
an in-line comment that is terminated by an end-of-line. This is particularly
pertinent when using C-style logical tokens, which may contain exclamations.
.PP
INTEGER or LOGICAL expressions may be used to select output lines.
An expression is composed of INTEGER and LOGICAL constants, parameters
and operators. Operators are
.PP
.nf
.fam C
       #------#------#------#------#------#------#------#
       |  +   |  -   |  *   |  /   |  **  |  (   |  )   |
       #------#------#------#------#------#------#------#
       | .EQ. | .NE. | .GE. | .GT. | .LE. | .LT. |
       |  ==  |  /=  |  >=  |  >   |  <=  |  <   |
       |      |  !=  |      |      |      |      | <== C-style
       #------#------#------#------#------#------#
       |.NOT. |.AND. | .OR. | .EQV.|.NEQV.|
       |  !   |  &&  |  ||  |  ==  |  !=  |        <== C-style
       #------#------#------#------#------#

.fam T
.fi
The suggested suffix for Fortran input files is ".ff" for code files unless
they contain $SYSTEM directives in which case ".FF" is preferred. $INCLUDE
files should use ".ffinc" and ".FFINC" if they include \fBprep\fP(1) directives.
This naming convention is not required.
.PP
The syntax for the directive lines is as follows:
.PP
.nf
.fam C
    :VARIABLE DEFINITION FOR CONDITIONALS
     $DEFINE   variable_name[=expression]                 [! comment ]
     $REDEFINE variable_name[=expression]                 [! comment ]
     $UNDEFINE|$UNDEF variable_name(s)                    [! comment ]

    :CONDITIONAL CODE SELECTION
     $IF  logical integer-based expression |
     $IFDEF variable-name |
     $IFNDEF variable_name                                [! comment ]
             { sequence of source statements}
     [$ELSEIF|$ELIF logical integer-based expression      [! comment ]
             { sequence of source statements}]
     [$ELSE                                               [! comment ]
             { sequence of source statements}]
     $ENDIF                                               [! comment ]

     $STOP     [stop_value]                               [! comment ]
     $QUIT                                                [! comment ]

    :MACRO STRING EXPANSION AND TEXT REPLAY
     $SET      varname  string
     $IMPORT   envname(s)
     $PARCEL   blockname                                  [! comment ]
     $POST     blockname                                  [! comment ]

    :EXTERNAL FILES (see $BLOCK \.\.\. --file also)
     $OUTPUT   filename  [-append]                        [! comment ]
     $INCLUDE  filename                                   [! comment ]

    :TEXT BLOCK FILTERS
     $BLOCK    [comment|null|write|help|version|variable [-varname NAME]]
               [-file NAME [-append]]                     [! comment ]

    :IDENTIFIERS
     $IDENT | $@(#)    metadata                           [! comment ]

    :INFORMATION
     $MESSAGE  message_to_stderr
     $SHOW [defined_variable_name(s)]                     [! comment ]

    :SYSTEM COMMANDS
     $SYSTEM   system_command                             [! comment ]

.fam T
.fi
.SH OPTIONS
.TP
.B \fIdefine_list\fP, \fB-D\fP \fIdefine_list\fP
An optional space-delimited list of expressions
used to define variables before file processing
commences.
.TP
.B \fB-i\fP \fIinput_file(s)\fP
The default input file is stdin. Filenames are
space-delimited. In a list, @ represents stdin.
.TP
.B \fB-o\fP \fIoutput_file\fP
The default output file is stdout.
.TP
.B \fB-I\fP \fIinclude_directories\fP
The directories to search for files specified on
$INCLUDE directives.
.TP
.B \fB--prefix\fP ADE|letter
The default directive prefix character is "$".
Alternatives may be specified by providing an
ASCII Decimal Equivalent (Common values are 37=%
42=* 35=# 36=$ 64=@). If the value is not numeric
it is assumed to be a literal character.
.TP
.B \fB--noenv\fP
The $IFDEF and $IFNDEF directives test for an
internal \fBprep\fP(1) variable and then an
environment variable by default. This option
turns off testing for environment variables.
.TP
.B \fB--type\fP FILETYPE
this flag indicates to skip input lines until after a
specific start string is encountered and to stop once a
specific end string is found left-justified on lines by
themselves.
.PP
.nf
.fam C
                        FileType  Start_String            Stop_String
                        --------  ------------            -----------
                        md        ```fortran              ```
                        html      <xmp>                   </xmp>
                        tex       \\begin{minted}{Fortran} \\end{minted}
                        auto
                        none

.fam T
.fi
.RS
The special type "auto" may be specified, in which case
files will be processed according to their file suffix.
This allows for easily extracting code from common
document formats. This is particularly useful with extended
markdown formats, allowing for code source to be easily
documented and for tests in documents to be able to be
extracted and tested. "auto" switches processing mode
depending on input file suffix, treating supported file
prefixes ("md","html") appropriately.
.RE
.TP
.B \fB--start\fP STRING
Same as \fB--type\fP except along with \fB--stop\fP allows for custom
strings to be specified.
.RS
.TP
.B \fB--stop\fP STRING
Same as \fB--type\fP except along with \fB--start\fP allows for custom
strings to be specified.
.RE
.TP
.B \fB--system\fP
Allow system commands on $SYSTEM directives to
be executed.
.TP
.B \fB--keeptabs\fP
By default tab characters are expanded assuming
a stop has been set every eight columns; and
trailing carriage-return characters are removed.
Use this flag to prevent this processing from
occurring.
.TP
.B \fB--comment\fP
try to style comments generated in $BLOCK blocks
for other utilities such as doxygen. Default is to
prefix lines with '! '. Allowed keywords are
currently "default", "doxygen","none","ford".
THIS IS AN ALPHA FEATURE AND NOT FULLY IMPLEMENTED.
.TP
.B \fB--ident\fP
The output of the $IDENT directive is in the form of a
comment by default. If this flag is set the output is
of the form described in the $IDENT documentation
so executables and object code can contain the metadata
for use with the \fBwhat\fP(1) command. Note this generates an
unused variable which some compilers might optimize
away depending on what compilation options are used.
.TP
.B \fB-d\fP ignore|remove|blank
Enable special treatment for lines beginning
with "d" or "D" The letter will be left as-is
(the default); removed; or replaced with a blank
character. This non-standard syntax has been
used to support the optional compilation of
"debug" code by many Fortran compilers when
compiling fixed-format Fortran source.
.TP
.B \fB--width\fP \fIn\fP
Maximum line length of the output file. The default is 1024.
Typically used to trim fixed-format FORTRAN code that
contains comments or "ident" labels past column 72
when compiling fixed-format Fortran code.
.TP
.B \fB--verbose\fP
All commands on a $SYSTEM directive are echoed
to stderr with a + prefix. Text following the
string "@(#)" is printed to stderr similar to
the Unix command \fBwhat\fP(1) but is otherwise
treated as other text input.
.TP
.B \fB--version\fP
Display version and exit
.TP
.B \fB--help\fP
Display documentation and exit.
.SS   DIRECTIVES

$DEFINE|$REDEFINE variable_name [=expression]
.PP
A $DEFINE may appear anywhere in a source file. If the value is ".TRUE."
or ".FALSE." then the parameter is of type LOGICAL, otherwise the
parameter is of type INTEGER and the value must be an INTEGER. If no
value is supplied, the parameter is of type INTEGER and is given the
value 1.
.PP
Variables are defined from the point they are encountered in a $DEFINE
directive or the command line until program termination unless explicitly
undefined with a $UNDEFINE directive.
.PP
If defined after first undefined a warning is generated on stderr.
The $REDEFINE directive is identical to the $DEFINE directive accept no
warning is produced if the variable is already defined.
.PP
Example:
.PP
.nf
.fam C
    $define A=1
    $define B= 10 - 1
    $define C=1+1
    $if ( A + B ) / C .eq. 1
       (a+b)/c is one
    $endif

.fam T
.fi
$IF/$ELSEIF/$ELSE/$ENDIF directives
.PP
Each of the control lines delineates a block of FORTRAN source. If the
expression following the $IF is ".TRUE.", then the lines of FORTRAN
source following are output. If it is ".FALSE.", and an $ELSEIF
follows, the expression is evaluated and treated the same as the $IF. If
the $IF and all $ELSEIF expressions are ".FALSE.", then the lines of
source following the $ELSE are output. A matching $ENDIF ends the
conditional block.
.PP
$IFDEF/$IFNDEF directives
.PP
$IFDEF and $IFNDEF are special forms of the $IF directive that simply test
if a variable name is defined or not. Essentially, these are equivalent:
.PP
.nf
.fam C
     $IFDEF varname  ==> $IF DEFINED(varname)
     $IFNDEF varname ==> $IF .NOT. DEFINED(varname)

.fam T
.fi
except that environment variables are tested as well if the \fB--noenv\fP option
is not specified.
.PP
$IDENT metadata [-language fortran|c|shell]
.PP
When the command line option "\fB-ident\fP" is specified this directive
writes a line using SCCS-metadata format of one of the following forms:
.PP
.nf
.fam C
     language:
     fortran   character(len=*),parameter::ident="@(#)metadata"
     c         #ident "@(#)metadata"
     shell     #@(#) metadata

.fam T
.fi
This string is generally included for use with the \fBwhat\fP(1) command.
.PP
"$@(#)" is an alias for "$IDENT" so the source file itself will contain
SCCS-metadata so the metadata can be displayed with \fBwhat\fP(1).
.PP
The default language is "fortran". Depending on your compiler and the
optimization level used when compiling, these strings may or may not
remain in the object files and executables created.
.PP
Do not use the characters double-quote, greater-than, backslash (ie. ">\\)
in the metadata to remain compatible with SCCS metadata syntax.
Do not use strings starting with " -" either.
.PP
$OUTPUT filename [-append]
.PP
Specify the output file to write to. Overrides the initial output file
specified with command line options. If no output filename is given
revert back to initial output file. @ is a synonym for stdout.
.PP
.nf
.fam C
      -append [.true.|.false]

.fam T
.fi
Files open at the beginning by default. Use the \fB-append\fP switch to
append to the end of an existing file instead of overwriting it.
.PP
$INCLUDE filename
.PP
Read in specified input file. Fifty (50) nesting levels are allowed.
.PP
$PARCEL [name]
.PP
The lines between a "$PARCEL name" and "$PARCEL" block are written WITHOUT
expanding directives to a scratch file that can then be read in with the
$POST directive much like a named file can be with $INCLUDE.
.PP
$POST name
.PP
Read in the scratch file created by the $PARCEL directive. Combined with
$SET directives this allows you to replay a section of input and replace
strings as a simple templating technique.
.PP
$SET name string
.PP
If a $SET directive defines a name \fBprep\fP(1) enters expansion mode. In this
mode anywhere the string "${NAME}" is encountered in subsequent output it
is replaced by "string". Comments should not be used on a $SET directive.
Note expansion of a line may cause it to be longer than allowed by some
compilers. Automatic breaking into continuation lines does not occur.
.PP
IF A $SET DIRECTIVE HAS BEEN DEFINED the "standard" preprocessor values
${FILE}, ${LINE}, ${DATE}, and ${TIME} are also available. The time
refers to the time of processing, not the time of compilation or loading.
.PP
$IMPORT \fBnames\fP(s)
.PP
The values of environment variables may be imported such that their names
and values will be set as if a $SET command had been done on them.
.TP
.B $BLOCK [comment|null|write|help|version
[-file NAME [-append]]
or
.TP
.B $BLOCK VARIABLE \fB--varname\fP NAME
[-\fB-file\fP NAME]
.PP
.nf
.fam C
      COMMENT:   write text prefixed by an exclamation and a space
      WRITE:     write text as Fortran WRITE(3f) statements
                 The Fortran generated is free-format. It is assumed the
                 output will not generate lines over 132 columns.
      HELP:      write text as a subroutine called HELP_USAGE
      VERSION:   write text as a subroutine called HELP_VERSION prefixing
                 lines with @(#) for use with the what(1) command.
      NULL:      Do not write into current output file
      VARIABLE:  write as a text variable. The name may be defined using
                 the --varname switch. Default name is "textblock".
      END:       End block of specially processed text

.fam T
.fi
If the "\fB-file\fP NAME" option is present the *unaltered* text is written to
the specified file. This allows documentation to easily be maintained in
the source file. It can be tex, html, markdown or any plain text.
The filename will be prefixed with $PREP_DOCUMENT_DIR/doc/ . If the
environment variable $PREP_DOCUMENT_DIR is not set the option is ignored.
.PP
The text can easily be processed by other utilities such as \fBmarkdown\fP(1)
or \fBtxt2man\fP(1) to produce \fBman\fP(1) pages and HTML documents. $SYSTEM commands
may follow the $BLOCK block text to optionally post-process the doc files.
.PP
A blank value or "END" returns to normal output processing.
.PP
$SHOW \fB[variable_name\fP(s)]
.PP
Shows current state of \fBprep\fP(1); including variable names and values; and
the name of the current input files. All output is preceded by an
exclamation character.
.PP
If a list of defined variable names is present only those variables and
their values are shown.
.PP
Example:
.PP
.nf
.fam C
    prep A=10 B C D -o paper
    $define z=22
    $show B Z
    $show
    $stop 0

.nf
.fam C
     > !  B  =  1
     > !  Z  =  22
     > !================================================================
     > !
     > ! Current state of prep(1):(18:39 20 Jun 2021)
     > ! Total lines read \.\.\............. 2
     > ! Conditional nesting level\.\.\..... 0
     > ! G_WRITE (general processing)\.\.\.. T
     > ! G_LLWRITE (write input lines)\.\.\. T
     > ! Arguments \.\.\.................... A=10 B C D -o paper
     > ! Open files:
     > !    unit ! line number ! filename
     > !       5 !           2 ! @
     > ! INCLUDE directories:
     > !    .
     > ! Variables:
     > !    $DEFINE UNKNOWN  =  0
     > !    $DEFINE LINUX  =  1
     > !    $DEFINE MACOS  =  2
     > !    $DEFINE WINDOWS  =  3
     > !    $DEFINE CYGWIN  =  4
     > !    $DEFINE SOLARIS  =  5
     > !    $DEFINE FREEBSD  =  6
     > !    $DEFINE OPENBSD  =  7
     > !    $DEFINE OS  =  1
     > !    $DEFINE A  =  10
     > !    $DEFINE B  =  1
     > !    $DEFINE C  =  1
     > !    $DEFINE D  =  1
     > !    $DEFINE Z  =  22
     > ! Parcels:
     > !================================================================

.fam T
.fi
$STOP stop_value
.PP
Stops input file processing. An optional integer value of 0 to 20
will be returned as a status value to the system where supported. A
value of two ("2") is returned if no value is specified. Any value
from one ("1") to twenty ("20") also causes an implicit execution of
the "$SHOW" directive before the program is stopped. A value of "0"
causes normal program termination. "$QUIT" is an alias for "$STOP 0".
.PP
$SYSTEM system_command
.PP
If system command processing is enabled using the \fB--system\fP switch system
commands can be executed for such tasks as creating files to be read or to
further process documents created by $BLOCK. $SYSTEM directives are ignored
by default; as you clearly need to ensure the input file is trusted before
before allowing commands to be executed. Commands that are system-specific
may need to be executed conditionally as well.
.PP
Examples:
.PP
.nf
.fam C
    $! build variable definitions using GNU/Linux commands
    $SYSTEM echo system=`hostname` > compiled.h
    $SYSTEM echo compile_time="`date`" >> compiled.h
    $INCLUDE compiled.h

    $! obtain up-to-date copy of source file from HTTP server:
    $SYSTEM wget http://repository.net/src/func.F90 -O - >_tmp.f90
    $INCLUDE _tmp.f90
    $SYSTEM  rm _tmp.f90

.fam T
.fi
$UNDEFINE variable_name
.PP
A symbol defined with $DEFINE can be removed with the $UNDEFINE
directive.
.PP
\fBDEFINED\fP(variable_name)
.PP
A special function called \fBDEFINED\fP() may appear only in a $IF or $ELSEIF.
If "variable_name" has been defined at that point in the source code,
then the function value is ".TRUE.", otherwise it is ".FALSE.". A name is
defined only if it has appeared in the source previously in a $DEFINE
directive or been declared on the command line.
The names used in compiler directives are district from names in the
FORTRAN source, which means that "a" in a $DEFINE and "a" in a FORTRAN
source statement are totally unrelated.
The \fBDEFINED\fP() parameter is NOT valid in a $DEFINE directive.
.PP
Example:
.PP
.nf
.fam C
    >        Program test
    > $IF .NOT. DEFINED (inc)
    >        INCLUDE ''comm.inc''
    > $ELSE
    >        INCLUDE ''comm2.inc''
    > $ENDIF
    >        END

.fam T
.fi
The file, "comm.inc" will be included in the source if the parameter,
"inc", has not been previously defined, while INCLUDE "comm2.inc" will
be included in the source if "inc" has been previously defined. This is
useful for setting up a default inclusion.
.PP
Predefined values are
.PP
.nf
.fam C
    UNKNOWN = 0 LINUX   = 1 MACOS   = 2 WINDOWS = 3
    CYGWIN  = 4 SOLARIS = 5 FREEBSD = 6 OPENBSD = 7
    In addition OS is set to what the program guesses the system type is.

.fam T
.fi
$MESSAGE WARNING message
.PP
Write message to stderr.
.PP
Messages for $MESSAGE do not treat "! " as starting a comment
.SH LIMITATIONS

$IF constructs can be nested up to 20 levels deep. Note that using
more than two levels typically makes input files less readable.
.PP
$BLOCK is required after a $BLOCK or \fB--file\fP FILENAME is not written.
.PP
Nesting of $BLOCK sections not allowed.
.RE
.PP
Input files
.RS
.IP \(bu 3
lines are limited to 1024 columns. Text past column 1024 is ignored.
.IP \(bu 3
files currently opened cannot be opened again.
.IP \(bu 3
a maximum of 50 files can be nested by $INCLUDE
.IP \(bu 3
filenames cannot contain spaces on the command line.
.RE
.PP
Variable names
.RS
.IP \(bu 3
are limited to 31 characters.
.IP \(bu 3
must start with a letter (A-Z).
.IP \(bu 3
are composed of the letters A-Z, digits 0-9 and _ and $.
.IP \(bu 3
2048 variable names may be defined at a time.
.SH EXAMPLES

Define variables on command line:
.PP
.nf
.fam C
   Typically, variables are defined on the command line when prep(1) is
   invoked but can be grouped together into small files that are included
   with a $INCLUDE or as input files.

.nf
.fam C
     prep HP size=64 -i hp_directives.dirs test.F90 -o test_out.f90

.fam T
.fi
.RS
defines variables HP and SIZE as if the expressions had been on a
$DEFINE and reads file "hp_directives.dirs" and then test.F90.
Output is directed to test_out.f90
.RE
.PP
Basic conditionals:
.PP
.nf
.fam C
   > $! set variable "a" if not specified on the prep(1) command.
   > $IF .NOT.DEFINED(A)
   > $   DEFINE a=1  ! so only define the first version of SUB(3f) below
   > $ENDIF
   >    program conditional_compile
   >       call sub()
   >    end program conditional_compile
   > $! select a version of SUB depending on the value of variable "a"
   > $IF a .EQ. 1
   >    subroutine sub
   >       print*, "This is the first SUB"
   >    end subroutine sub
   > $ELSEIF a .eq. 2
   >    subroutine sub
   >       print*, "This is the second SUB"
   >    end subroutine sub
   > $ELSE
   >    subroutine sub
   >       print*, "This is the third SUB"
   >    end subroutine sub
   > $ENDIF

.fam T
.fi
Common use of $BLOCK
.PP
.nf
.fam C
   > $!
   > $BLOCK NULL --file manual.tex
   > This is a block of text that will be ignored on output but
   > optionally written to a doc/ file when $PREP_DOCUMENT_DIR is set.
   > $BLOCK
   > $!
   > $BLOCK COMMENT --file manual.tex --append
   > This is a block of text that will be converted to comments and
   > optionally appended to a doc/ file when $PREP_DOCUMENT_DIR is set.
   > $BLOCK
   > $!

.fam T
.fi
Creating a \fBhelp_usage\fP(3f) subroutine and writing the same documentation
to a doc file (if the environment variable $PREP_DOCUMENT_DIR is set).
.PP
.nf
.fam C
   > $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   > $! generate help_usage() procedure and file to run thru txt2man(1)
   > $! to make man(1) page if $PREP_DOCUMENT_DIR is set.
   > $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   > $BLOCK HELP --file conditional_compile.man
   > NAME
   >    conditional_compile - basic example for prep(1) pre-processor.
   > SYNOPSIS
   >    conditional_example [--help] [--version]
   > DESCRIPTION
   >    This is a basic example program showing how documentation can be
   >    used to generate program help text
   > OPTIONS
   >    --help     display this help and exit
   >    --version  output version information and exit
   > $BLOCK

.fam T
.fi
Creating a \fBhelp_version\fP(3f) subroutine
.PP
.nf
.fam C
   > $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
   > $! generate help_version() procedure
   > $BLOCK VERSION
   > DESCRIPTION: example program showing conditional compilation
   > PROGRAM:     conditional_compile
   > VERSION:     1.0.0, 20160703
   > AUTHOR:      John S. Urban
   > $BLOCK
   > $!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

.fam T
.fi
Sample program using \fBhelp_usage\fP(f), \fBhelp_version\fP(3f) and \fBM_kracken95\fP(3f):
.PP
.nf
.fam C
   > program conditional_compile
   >    use M_kracken95, only : kracken, lget
   >    ! use M_kracken95 module to crack command line arguments
   >    call kracken("cmd","--help .false. --version .false.")
   >    ! call routine generated by $BLOCK HELP
   >    call help_usage(lget("cmd_help"))
   >    ! call routine generated by $BLOCK VERSION
   >    call help_version(lget("cmd_version"))
   > end program conditional_compile

.fam T
.fi
.SS SET USAGE
Note values are case-sensitive but variable names are not, and there are
pre-defined values for input file, line in input file, date and time that
are NOT ACTIVE until at least one $SET or $IMPORT directive is processed.
That is, unless a variable name is defined no ${NAME} expansion occurs.
.PP
.nf
.fam C
   > $set author  William Shakespeare
   > $import HOME
   > write(*,*)'By ${AUTHOR}'
   > write(*,*)'File ${FILE}'
   > write(*,*)'Line ${LINE}'
   > write(*,*)'Date ${DATE}'
   > write(*,*)'Time ${TIME}'
   > write(*,*)'HOME ${HOME}'

.fam T
.fi
.SH AUTHOR
John S. Urban
.SH LICENSE
.SS   MIT

